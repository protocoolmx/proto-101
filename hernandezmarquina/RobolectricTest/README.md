# Robolectric test

Basic example, to how use Robolectric to test our code in Android Studio.

When our code is suspect to continuous refactoring, our unit tests can help insured that the new code changes continue to validate all tests previously performed.

# Test types and location
The location of your test code depends on the type of test you are writing. Android Studio provides source code directories (source sets), for the following two types of tests:

Local unit tests
Located at module-name/src/test/java/.

These are tests that run on your machine's local Java Virtual Machine (JVM). Use these tests to minimize execution time when your tests have no Android framework dependencies or when you can mock the Android framework dependencies.

At runtime, these tests are executed against a modified version of android.jar where all final modifiers have been stripped off. This lets you use popular mocking libraries, like Mockito.

Instrumented tests
Located at module-name/src/androidTest/java/.

These are tests that run on a hardware device or emulator. These tests have access to Instrumentation APIs, give you access to information such as the Context of the app you are testing, and let you control the app under test from your test code. Use these tests when writing integration and functional UI tests to automate user interaction, or when your tests have Android dependencies that mock objects cannot satisfy.

Because instrumented tests are built into an APK (separate from your app APK), they must have their own AndroidManifest.xml file. However, Gradle automatically generates this file during the build so it is not visible in your project source set. You can add your own manifest file if necessary, such as to specify a different value for "minSdkVersion" or register run listeners just for your tests. When building your app, Gradle merges multiple manifest files into one manifest.

[developers android](https://developer.android.com/studio/test/index.html)

## Testing with Robolectric

Robolectric allows us to execute tests directly in the virtual machine of Java without needing to launch an emulator, thanks to classes called Shadows.

Robolectric defines many shadow classes, which modify or extend the behavior of classes in the Android OS. When an Android class is instantiated, Robolectric looks for a corresponding shadow class, and if it finds one it creates a shadow object to associate with it. Every time a method is invoked on an Android class, Robolectric ensures that the shadow class' corresponding method is invoked first (if there is one), so it has a chance to work its magic. This applies to all methods, even static and final methods, because Robolectric is extra tricky!

[Shadows](http://robolectric.org/extending/)
[Shadow classes](https://github.com/robolectric/robolectric/tree/master/robolectric-shadows/shadows-core/src/main/java/org/robolectric/shadows)


First add the following to your build.gradle:

```
testCompile "org.robolectric:robolectric:3.2.2"
```

Annotate your test with the Robolectric test runner:

```
@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class)
public class SandwichTest {
}
```

**NOTE:** that you must specify the constants field which points to the BuildConfig.class generated by the build system. Robolectric uses the constants in the class to compute the output paths used by Gradle when building your project. Without these values, Robolectric will not be able to find your merged manifest, resources, or assets.

If you are on Linux or on a Mac, you will probably need to configure the default JUnit test runner configuration in order to work around a bug where Android Studio does not set the working directory to the module being tested. This can be accomplished by editing the run configurations, Defaults -> JUnit and changing the working directory value to $MODULE_DIR$.

![Image configurations](http://robolectric.org/images/android-studio-configure-defaults-4bf48402.png)

[Robolectric-samples](https://github.com/robolectric/robolectric-samples)



